plugins {
    id 'java'
    id 'maven-publish'
    id 'idea'
    id 'application'
    id 'edu.sc.seis.launch4j' version '2.4.9'
    id 'org.beryx.runtime' version '1.12.1'
    id 'org.openjfx.javafxplugin' version '0.0.8'
}

group = 'BIP'
version = '1.9'
description = 'bip'
mainClassName = 'Launcher'
applicationName = "Barcode Image Processor"

apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'edu.sc.seis.launch4j'
apply plugin: 'org.beryx.runtime'
apply plugin: 'org.openjfx.javafxplugin'

repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
    maven {
        url = uri('https://repo1.maven.org/maven2/com/google/zxing/javase/3.4.1/javase-3.4.1.jar')
    }
}

sourceCompatibility = 15
targetCompatibility = 15

java {
    modularity.inferModulePath = true
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

javafx {
    version = "15"
    modules = ['javafx.controls', 'javafx.base', 'javafx.graphics', 'javafx.fxml',
               'javafx.swing', 'javafx.media', 'javafx.web']
}

dependencies {
    implementation 'org.apache.commons:commons-imaging:1.0-alpha1'
    implementation 'com.google.zxing:javase:3.4.1'
    implementation 'com.google.zxing:core:3.4.1'
    implementation 'org.controlsfx:controlsfx:9.0.0'
    implementation 'org.openjfx:javafx:15'

    compile 'org.openjfx:javafx-base:15'
    compile 'org.openjfx:javafx-graphics:15'
    compile 'org.openjfx:javafx-controls:15'
    compile 'org.openjfx:javafx-fxml:15'
    compile 'org.openjfx:javafx-swing:15'
    compile 'org.openjfx:javafx-media:15'
    compile 'org.openjfx:javafx-web:15'
    compile 'org.controlsfx:controlsfx:9.0.0'
}

jar {
    manifest {
        attributes(
                'Class-Path': configurations.runtimeClasspath.files.collect { it.name }.join(' '),
                'Main-Class': 'Launcher'
        )
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

runtime {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
    jpackage {
        mainClass = 'Launcher'
        mainJar = 'lib/' + project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files.getSingleFile().name
        //targetPlatform('windows-x64', "${buildDir}/${jreDistributionPath}")
        appVersion = version
        installerName = 'BIP-installer-win64'
        installerOutputDir = file("$buildDir/jpackage-installer")
        installerType = "msi"
        installerOptions += ['--resource-dir', "src/main/resources"]
        installerOptions += ['--win-per-user-install', '--win-dir-chooser', '--win-menu', '--win-shortcut']
    }
}

tasks.runtime.doLast {
    copy {
        from('src/main/resources')
        into("$buildDir/image/bin")
    }
}

/*
ext.l4jCmdPath = project.hasProperty( 'l4jCmdPath' ) ? project.getProperty( 'l4jCmdPath' ) : 'launch4j' // default requires launch4j on the path
ext.l4jxmlFileName = 'launch4j.xml'
ext.l4jOutputBaseFileName = "${rootProject.applicationName}-${version}"
def folderName = "${l4jOutputBaseFileName}"
ext.l4jOutputDir = "launch4j/${folderName}"  // path is relative to buildDir
ext.bundledJrePath = './jre'               // path is relative to launch4j.outputDir and must start with '.'

ext.jreBuildNumber = 281 // Default to version 74 of the Oracle Java 8 JRE

// allow ext.jreBuildNumber to be overridden by the gradle command line
// e.g. gradle createExe -PjreBuildOverride=40
//   or gradle distSfx -PjreBuildOverride=40
//   or gradle extraProperties -PjreBuildOverride=40
if( project.hasProperty( 'jreBuildOverride' ) ) {
    project.jreBuildNumber = Integer.parseInt( jreBuildOverride )
}

ext.jreTargetVersion = "1.8.0_${jreBuildNumber}"   // target JRE version   (e.g. 1.8.0_74)
ext.jrePriorVersion  = "1.8.0_${jreBuildNumber - 1}" // target JRE version-1 (e.g. 1.8.0_73)
// these are used by the zip and distribution tasks after launch4j has run
ext.jreArchiveSourcePath = 'jre' // path is relative to the root of this subproject
ext.jreDistributionPath = "$l4jOutputDir/$bundledJrePath"
ext.win64ZipBaseFileName = "${l4jOutputBaseFileName}"

launch4j {
    mainClassName = 'Launcher'
    cmdLine = project.l4jCmdPath
    xmlFileName = project.l4jxmlFileName
    mainClassName = project.mainClassName
    outputDir = project.l4jOutputDir
    outfile = "${l4jOutputBaseFileName}.exe"
    jar = 'lib/' + project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files.getSingleFile().name   // path is relative to outputDir
    //icon = '../../../../../platform/windows/resources/icons/vZomeLogo.ico'  // path is relative to outputDir
    //jreMaxVersion = project.jreTargetVersion
    //jreMinVersion = project.jrePriorVersion
    bundledJrePath = project.bundledJrePath // path is relative to launch4j.outputDir
    bundledJre64Bit = true
    //jdkPreference = 'jdkOnly' // default is 'preferJre'
    jreRuntimeBits = '64'

    //opt = '-Xmx3072M'
    // Most of the rootProject.jvmArgs have apple in the name. Exclude those...
    //rootProject.project('desktop').jvmArgs.each { entry ->
      //  if(!entry.key.contains("apple.")) {
        //    opt = opt + " -D${entry.key}=${entry.value}"
       // }
    //}
    cmdLine = ''
    def sp = ''
    //rootProject.project('desktop').vzomeArgs.each { entry ->
       // cmdLine = cmdLine + "${sp}${entry}"
      //  sp = ' '
   // }

    // Several of the plugin property names don't exactly match the corresponding XML element.
    version = project.version
    textVersion = project.version
    productName = rootProject.name
    internalName = rootProject.name
}

// msg is only displayed if the gradle logging level is set with command line parameter '--info' or '--debug'
// so use logInfo instead of println
def logInfo(msg) {
    getLogger().info msg
}

task cleanJre {
    outputs.upToDateWhen {
        return !( new File(project.jreDistributionPath).exists() );
    }
    doLast() {
        delete project.jreDistributionPath
        logInfo "Deleting JRE distribution directory: ${jreDistributionPath}"
    }
    group = 'Build'
    description = "Removes the JRE distribution directory."
}
// This dependency is not really needed as long as jreDistributionPath is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanJre

task cleanDistributions {
    def folder = "${buildDir}/distributions"
    outputs.upToDateWhen {
        return !( new File(folder).exists() );
    }
    doLast() {
        delete folder
        logInfo "Deleting installer distribution directory: ${folder}"
    }
    group = 'Build'
    description = "Removes the installer distribution directory."
}
// This dependency is not really needed as long as folder is under $BuildDir but it doesn't hurt.
clean.dependsOn cleanDistributions

task extractWin64Jre(type: Sync) {
    def src = "${jreArchiveSourcePath}/jdk15.zip"
    def dst = "${buildDir}/${jreDistributionPath}"
    from zipTree(src)
    into dst
    group = 'Windows Distribution'
}

runtime {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']
    targetPlatform('windows-x64', "${buildDir}/${jreDistributionPath}")
}

tasks.runtime.doLast {
    copy {
        from('src/main/resources')
        into("$buildDir/image/bin")
    }
}

tasks.runtime.dependsOn(tasks.extractWin64Jre)

task deleteFatJdk(type: Delete) {
    delete "$buildDir/launch4j/Barcode Image Processor-$version/jre"
}

tasks.deleteFatJdk.dependsOn(tasks.runtime)

task copyCutDownJreToL4j(type: Copy) {
    from "$buildDir/image/BarcodeImageProcessor-windows-x64"
    into "$buildDir/launch4j/Barcode Image Processor-$version/jre"
}

tasks.copyCutDownJreToL4j.dependsOn(tasks.deleteFatJdk)


task zipWin64Distribution(type: Zip) {
    def src = "${buildDir}/launch4j"
    from src
    exclude "${folderName}/${launch4j.xmlFileName}"
    baseName = win64ZipBaseFileName
    extension = 'zip'
    // explicitly set the archiveName rather than using the default which appends the version
    archiveName = baseName + '.' + extension
    group = 'Windows Distribution'
    description = 'Generates the 64-bit Windows zip file distribution.'
    dependsOn { [ "createExe", "copyCutDownJreToL4j" ] }
}

task createWin64sfxInstaller(type: FileConcatTask) {
    // First source file MUST be unzipsfx-x64.exe which is extracted directly from unzipsfx.zip.
    // Second source file is the output of zipWin64Distribution
    // Note that the zipTree call is wrapped in closure so that configuration is only resolved at execution time.
    source = files(
            ( { zipTree('unzipsfx/unzipsfx.zip').matching { include 'unzipsfx-x64.exe' } } ),
            "${zipWin64Distribution.archivePath}"
    )
    destination = "${zipWin64Distribution.archivePath}".replace('.zip', '.exe')
    doLast() {
        println "Generated self-extracting zip installer ${getDestination()}"
    }

    group = 'Windows Distribution'
    description = 'Generates the 64-bit Windows self-extracting installer.'
    dependsOn zipWin64Distribution
}

task distSfx {
    group = 'Windows Distribution'
    description = 'Primary task to be invoked for creating the self-extracting installer with launch4j and subsequent build steps.'
    dependsOn createWin64sfxInstaller
}

class FileConcatTask extends SourceTask {
    private destination
    @OutputFile File getDestination() { project.file(destination) }
    void setDestination(destination) { this.destination = destination }

    @TaskAction
    void doBinaryFileConcat() {
        logInfo 'Concatenating:'
        getDestination().withOutputStream { out ->
            getSource().files.each {
                logInfo("  +-<<--- ${it.name}")
                it.withInputStream { out << it }
            }
        }
        logInfo '  |'
        logInfo "  +--->>> ${getDestination()}"
    }

    public void logInfo(String msg) {
        getLogger().info(msg)
    }
}*/
